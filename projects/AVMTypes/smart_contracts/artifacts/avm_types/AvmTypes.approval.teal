#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0 64
    bytecblock 0x151f7c75
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txn NumAppArgs
    bz main_bare_routing@40
    pushbytess 0x53ff2c2e 0x9111c4bc 0xe5cd81c9 0xc8230fd7 0xe470e608 0x8551ef3a 0x03074b19 0x7240b366 0xa278f98f 0xb377be6d 0xa4af8ee4 0xe320bc5e 0xbd9122f9 0xb5ce8e03 0x16853974 0x42c5bb8f 0xaa5ac1c9 0x64e008f0 0xaabbec83 0x36f9eaad 0x36d24141 0xce66f2ea 0x4d486e99 0x699b2a18 0x258f73ac 0x50e2627e 0x9250b856 0x28ee24d0 0xc7c4e86a 0x1b67a42e 0x7b832998 0xe0da070e 0xdaf56cd3 0xb97093f3 0xb61603f2 // method "stringReadonly(string)string", method "string(string)string", method "stringArray(string[])string[]", method "bytes(byte[])byte[]", method "boolean(bool)bool", method "biguint(uint512)uint512", method "struct((address,uint256))(address,uint256)", method "innerStruct((uint64,(address,uint256)))(uint64,(address,uint256))", method "PaymentTxn(pay)byte[]", method "ApplicationCallTxn(appl)byte[]", method "AssetTransferTxn(axfer)byte[]", method "KeyRegistrationTxn(keyreg)byte[]", method "Transaction(txn)byte[]", method "arc4StaticBytes8(byte[8])byte[8]", method "arc4StaticBytes32(byte[32])byte[32]", method "arc4StaticBytes1020(byte[1020])byte[1020]", method "arc4DynamicBytes(byte[])byte[]", method "arc4Address(address)address", method "arc4Bool(bool)bool", method "arc4Byte(byte)byte", method "arc4DynamicArrayOfStruct((address,uint256)[])(address,uint256)[]", method "arc4StaticArrayOf2Bytes(byte[2])byte[2]", method "arc4StaticArrayOf2Structs((address,uint256)[2])(address,uint256)[2]", method "arc4UFixed8x16(ufixed8x16)ufixed8x16", method "arc4UFixed512x160(ufixed512x160)ufixed512x160", method "arc4UintN8(uint8)uint8", method "arc4UintN512(uint512)uint512", method "arc4UintN128Alias(uint128)uint128", method "arc4UintN16Alias(uint16)uint16", method "arc4UintN256Alias(uint256)uint256", method "arc4UintN64Alias(uint64)uint64", method "arc4UintN8Alias(uint8)uint8", method "arc4UintN82Tuple((uint8,uint8))(uint8,uint8)", method "arc4UintN83Tuple((uint8,uint8,uint8))(uint8,uint8,uint8)", method "arc4ComplexTuple((address,(uint256,uint256),(uint256,uint256),(uint256,uint256)))(address,(uint256,uint256),(uint256,uint256),(uint256,uint256))"
    txna ApplicationArgs 0
    match main_stringReadonly_route@3 main_string_route@4 main_stringArray_route@5 main_bytes_route@6 main_boolean_route@7 main_biguint_route@8 main_struct_route@9 main_innerStruct_route@10 main_PaymentTxn_route@11 main_ApplicationCallTxn_route@12 main_AssetTransferTxn_route@13 main_KeyRegistrationTxn_route@14 main_Transaction_route@15 main_arc4StaticBytes8_route@16 main_arc4StaticBytes32_route@17 main_arc4StaticBytes1020_route@18 main_arc4DynamicBytes_route@19 main_arc4Address_route@20 main_arc4Bool_route@21 main_arc4Byte_route@22 main_arc4DynamicArrayOfStruct_route@23 main_arc4StaticArrayOf2Bytes_route@24 main_arc4StaticArrayOf2Structs_route@25 main_arc4UFixed8x16_route@26 main_arc4UFixed512x160_route@27 main_arc4UintN8_route@28 main_arc4UintN512_route@29 main_arc4UintN128Alias_route@30 main_arc4UintN16Alias_route@31 main_arc4UintN256Alias_route@32 main_arc4UintN64Alias_route@33 main_arc4UintN8Alias_route@34 main_arc4UintN82Tuple_route@35 main_arc4UintN83Tuple_route@36 main_arc4ComplexTuple_route@37

main_after_if_else@44:
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    intc_1 // 0
    return

main_arc4ComplexTuple_route@37:
    // smart_contracts/avm_types/contract.algo.ts:134-141
    // public arc4ComplexTuple(
    //   data: [
    //     arc4.Address,
    //     [arc4.UintN256, arc4.UintN256],
    //     [arc4.UintN256, arc4.UintN256],
    //     [arc4.UintN256, arc4.UintN256],
    //   ],
    // ): [arc4.Address, [arc4.UintN256, arc4.UintN256], [arc4.UintN256, arc4.UintN256], [arc4.UintN256, arc4.UintN256]] {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    dup
    extract 0 32 // on error: Index access is out of bounds
    dig 1
    extract 32 64 // on error: Index access is out of bounds
    dup
    extract 0 32 // on error: Index access is out of bounds
    swap
    extract 32 32 // on error: Index access is out of bounds
    dig 3
    extract 96 64 // on error: Index access is out of bounds
    dup
    extract 0 32 // on error: Index access is out of bounds
    swap
    extract 32 32 // on error: Index access is out of bounds
    uncover 5
    extract 160 64 // on error: Index access is out of bounds
    dup
    extract 0 32 // on error: Index access is out of bounds
    swap
    extract 32 32 // on error: Index access is out of bounds
    // smart_contracts/avm_types/contract.algo.ts:134-141
    // public arc4ComplexTuple(
    //   data: [
    //     arc4.Address,
    //     [arc4.UintN256, arc4.UintN256],
    //     [arc4.UintN256, arc4.UintN256],
    //     [arc4.UintN256, arc4.UintN256],
    //   ],
    // ): [arc4.Address, [arc4.UintN256, arc4.UintN256], [arc4.UintN256, arc4.UintN256], [arc4.UintN256, arc4.UintN256]] {
    uncover 5
    uncover 5
    concat
    uncover 4
    uncover 4
    concat
    uncover 3
    uncover 3
    concat
    uncover 3
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc4UintN83Tuple_route@36:
    // smart_contracts/avm_types/contract.algo.ts:131
    // public arc4UintN83Tuple(data: [arc4.UintN8, arc4.UintN8, arc4.UintN8]): [arc4.UintN8, arc4.UintN8, arc4.UintN8] {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    dup
    extract 0 1 // on error: Index access is out of bounds
    dig 1
    extract 1 1 // on error: Index access is out of bounds
    uncover 2
    extract 2 1 // on error: Index access is out of bounds
    // smart_contracts/avm_types/contract.algo.ts:131
    // public arc4UintN83Tuple(data: [arc4.UintN8, arc4.UintN8, arc4.UintN8]): [arc4.UintN8, arc4.UintN8, arc4.UintN8] {
    cover 2
    concat
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc4UintN82Tuple_route@35:
    // smart_contracts/avm_types/contract.algo.ts:128
    // public arc4UintN82Tuple(data: [arc4.UintN8, arc4.UintN8]): [arc4.UintN8, arc4.UintN8] {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    dup
    extract 0 1 // on error: Index access is out of bounds
    swap
    extract 1 1 // on error: Index access is out of bounds
    // smart_contracts/avm_types/contract.algo.ts:128
    // public arc4UintN82Tuple(data: [arc4.UintN8, arc4.UintN8]): [arc4.UintN8, arc4.UintN8] {
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc4UintN8Alias_route@34:
    // smart_contracts/avm_types/contract.algo.ts:125
    // public arc4UintN8Alias(data: arc4.UintN8): arc4.UintN8 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_0 // 0x151f7c75
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/avm_types/contract.algo.ts:125
    // public arc4UintN8Alias(data: arc4.UintN8): arc4.UintN8 {
    concat
    log
    intc_0 // 1
    return

main_arc4UintN64Alias_route@33:
    // smart_contracts/avm_types/contract.algo.ts:122
    // public arc4UintN64Alias(data: arc4.UintN64): arc4.UintN64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_0 // 0x151f7c75
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/avm_types/contract.algo.ts:122
    // public arc4UintN64Alias(data: arc4.UintN64): arc4.UintN64 {
    concat
    log
    intc_0 // 1
    return

main_arc4UintN256Alias_route@32:
    // smart_contracts/avm_types/contract.algo.ts:119
    // public arc4UintN256Alias(data: arc4.UintN256): arc4.UintN256 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_0 // 0x151f7c75
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/avm_types/contract.algo.ts:119
    // public arc4UintN256Alias(data: arc4.UintN256): arc4.UintN256 {
    concat
    log
    intc_0 // 1
    return

main_arc4UintN16Alias_route@31:
    // smart_contracts/avm_types/contract.algo.ts:116
    // public arc4UintN16Alias(data: arc4.UintN16): arc4.UintN16 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_0 // 0x151f7c75
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/avm_types/contract.algo.ts:116
    // public arc4UintN16Alias(data: arc4.UintN16): arc4.UintN16 {
    concat
    log
    intc_0 // 1
    return

main_arc4UintN128Alias_route@30:
    // smart_contracts/avm_types/contract.algo.ts:113
    // public arc4UintN128Alias(data: arc4.UintN128): arc4.UintN128 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_0 // 0x151f7c75
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/avm_types/contract.algo.ts:113
    // public arc4UintN128Alias(data: arc4.UintN128): arc4.UintN128 {
    concat
    log
    intc_0 // 1
    return

main_arc4UintN512_route@29:
    // smart_contracts/avm_types/contract.algo.ts:110
    // public arc4UintN512(data: arc4.UintN<512>): arc4.UintN<512> {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_0 // 0x151f7c75
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/avm_types/contract.algo.ts:110
    // public arc4UintN512(data: arc4.UintN<512>): arc4.UintN<512> {
    concat
    log
    intc_0 // 1
    return

main_arc4UintN8_route@28:
    // smart_contracts/avm_types/contract.algo.ts:107
    // public arc4UintN8(data: arc4.UintN<8>): arc4.UintN<8> {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_0 // 0x151f7c75
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/avm_types/contract.algo.ts:107
    // public arc4UintN8(data: arc4.UintN<8>): arc4.UintN<8> {
    concat
    log
    intc_0 // 1
    return

main_arc4UFixed512x160_route@27:
    // smart_contracts/avm_types/contract.algo.ts:104
    // public arc4UFixed512x160(data: arc4.UFixedNxM<512, 160>): arc4.UFixedNxM<512, 160> {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_0 // 0x151f7c75
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/avm_types/contract.algo.ts:104
    // public arc4UFixed512x160(data: arc4.UFixedNxM<512, 160>): arc4.UFixedNxM<512, 160> {
    concat
    log
    intc_0 // 1
    return

main_arc4UFixed8x16_route@26:
    // smart_contracts/avm_types/contract.algo.ts:101
    // public arc4UFixed8x16(data: arc4.UFixedNxM<8, 16>): arc4.UFixedNxM<8, 16> {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_0 // 0x151f7c75
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/avm_types/contract.algo.ts:101
    // public arc4UFixed8x16(data: arc4.UFixedNxM<8, 16>): arc4.UFixedNxM<8, 16> {
    concat
    log
    intc_0 // 1
    return

main_arc4StaticArrayOf2Structs_route@25:
    // smart_contracts/avm_types/contract.algo.ts:96-98
    // public arc4StaticArrayOf2Structs(
    //   data: arc4.StaticArray<structAddressUint256, 2>,
    // ): arc4.StaticArray<structAddressUint256, 2> {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_0 // 0x151f7c75
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/avm_types/contract.algo.ts:96-98
    // public arc4StaticArrayOf2Structs(
    //   data: arc4.StaticArray<structAddressUint256, 2>,
    // ): arc4.StaticArray<structAddressUint256, 2> {
    concat
    log
    intc_0 // 1
    return

main_arc4StaticArrayOf2Bytes_route@24:
    // smart_contracts/avm_types/contract.algo.ts:93
    // public arc4StaticArrayOf2Bytes(data: arc4.StaticArray<arc4.Byte, 2>): arc4.StaticArray<arc4.Byte, 2> {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_0 // 0x151f7c75
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/avm_types/contract.algo.ts:93
    // public arc4StaticArrayOf2Bytes(data: arc4.StaticArray<arc4.Byte, 2>): arc4.StaticArray<arc4.Byte, 2> {
    concat
    log
    intc_0 // 1
    return

main_arc4DynamicArrayOfStruct_route@23:
    // smart_contracts/avm_types/contract.algo.ts:88-90
    // public arc4DynamicArrayOfStruct(
    //   data: arc4.DynamicArray<structAddressUint256>,
    // ): arc4.DynamicArray<structAddressUint256> {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_0 // 0x151f7c75
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/avm_types/contract.algo.ts:88-90
    // public arc4DynamicArrayOfStruct(
    //   data: arc4.DynamicArray<structAddressUint256>,
    // ): arc4.DynamicArray<structAddressUint256> {
    concat
    log
    intc_0 // 1
    return

main_arc4Byte_route@22:
    // smart_contracts/avm_types/contract.algo.ts:84
    // public arc4Byte(data: arc4.Byte): arc4.Byte {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_0 // 0x151f7c75
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/avm_types/contract.algo.ts:84
    // public arc4Byte(data: arc4.Byte): arc4.Byte {
    concat
    log
    intc_0 // 1
    return

main_arc4Bool_route@21:
    // smart_contracts/avm_types/contract.algo.ts:81
    // public arc4Bool(data: arc4.Bool): arc4.Bool {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_0 // 0x151f7c75
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/avm_types/contract.algo.ts:81
    // public arc4Bool(data: arc4.Bool): arc4.Bool {
    concat
    log
    intc_0 // 1
    return

main_arc4Address_route@20:
    // smart_contracts/avm_types/contract.algo.ts:78
    // public arc4Address(data: arc4.Address): arc4.Address {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_0 // 0x151f7c75
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/avm_types/contract.algo.ts:78
    // public arc4Address(data: arc4.Address): arc4.Address {
    concat
    log
    intc_0 // 1
    return

main_arc4DynamicBytes_route@19:
    // smart_contracts/avm_types/contract.algo.ts:75
    // public arc4DynamicBytes(data: arc4.DynamicBytes): arc4.DynamicBytes {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_0 // 0x151f7c75
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/avm_types/contract.algo.ts:75
    // public arc4DynamicBytes(data: arc4.DynamicBytes): arc4.DynamicBytes {
    concat
    log
    intc_0 // 1
    return

main_arc4StaticBytes1020_route@18:
    // smart_contracts/avm_types/contract.algo.ts:72
    // public arc4StaticBytes1020(data: arc4.StaticBytes<1020>): arc4.StaticBytes<1020> {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_0 // 0x151f7c75
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/avm_types/contract.algo.ts:72
    // public arc4StaticBytes1020(data: arc4.StaticBytes<1020>): arc4.StaticBytes<1020> {
    concat
    log
    intc_0 // 1
    return

main_arc4StaticBytes32_route@17:
    // smart_contracts/avm_types/contract.algo.ts:69
    // public arc4StaticBytes32(data: arc4.StaticBytes<32>): arc4.StaticBytes<32> {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_0 // 0x151f7c75
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/avm_types/contract.algo.ts:69
    // public arc4StaticBytes32(data: arc4.StaticBytes<32>): arc4.StaticBytes<32> {
    concat
    log
    intc_0 // 1
    return

main_arc4StaticBytes8_route@16:
    // smart_contracts/avm_types/contract.algo.ts:66
    // public arc4StaticBytes8(data: arc4.StaticBytes<8>): arc4.StaticBytes<8> {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_0 // 0x151f7c75
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/avm_types/contract.algo.ts:66
    // public arc4StaticBytes8(data: arc4.StaticBytes<8>): arc4.StaticBytes<8> {
    concat
    log
    intc_0 // 1
    return

main_Transaction_route@15:
    // smart_contracts/avm_types/contract.algo.ts:52
    // public Transaction(data: gtxn.Transaction): bytes {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txn GroupIndex
    intc_0 // 1
    -
    // smart_contracts/avm_types/contract.algo.ts:52
    // public Transaction(data: gtxn.Transaction): bytes {
    callsub Transaction
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_KeyRegistrationTxn_route@14:
    // smart_contracts/avm_types/contract.algo.ts:49
    // public KeyRegistrationTxn(data: gtxn.KeyRegistrationTxn): bytes {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    pushint 2 // keyreg
    ==
    assert // transaction type is keyreg
    // smart_contracts/avm_types/contract.algo.ts:49
    // public KeyRegistrationTxn(data: gtxn.KeyRegistrationTxn): bytes {
    callsub KeyRegistrationTxn
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_AssetTransferTxn_route@13:
    // smart_contracts/avm_types/contract.algo.ts:46
    // public AssetTransferTxn(data: gtxn.AssetTransferTxn): bytes {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    // smart_contracts/avm_types/contract.algo.ts:46
    // public AssetTransferTxn(data: gtxn.AssetTransferTxn): bytes {
    callsub AssetTransferTxn
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_ApplicationCallTxn_route@12:
    // smart_contracts/avm_types/contract.algo.ts:43
    // public ApplicationCallTxn(data: gtxn.ApplicationCallTxn): bytes {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    // smart_contracts/avm_types/contract.algo.ts:43
    // public ApplicationCallTxn(data: gtxn.ApplicationCallTxn): bytes {
    callsub ApplicationCallTxn
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_PaymentTxn_route@11:
    // smart_contracts/avm_types/contract.algo.ts:40
    // public PaymentTxn(data: gtxn.PaymentTxn): bytes {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/avm_types/contract.algo.ts:40
    // public PaymentTxn(data: gtxn.PaymentTxn): bytes {
    callsub PaymentTxn
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_innerStruct_route@10:
    // smart_contracts/avm_types/contract.algo.ts:37
    // public innerStruct(data: innerStruct): innerStruct {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_0 // 0x151f7c75
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/avm_types/contract.algo.ts:37
    // public innerStruct(data: innerStruct): innerStruct {
    concat
    log
    intc_0 // 1
    return

main_struct_route@9:
    // smart_contracts/avm_types/contract.algo.ts:34
    // public struct(data: structAddressUint256): structAddressUint256 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_0 // 0x151f7c75
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/avm_types/contract.algo.ts:34
    // public struct(data: structAddressUint256): structAddressUint256 {
    concat
    log
    intc_0 // 1
    return

main_biguint_route@8:
    // smart_contracts/avm_types/contract.algo.ts:31
    // public biguint(data: biguint): biguint {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/avm_types/contract.algo.ts:31
    // public biguint(data: biguint): biguint {
    dup
    len
    intc_2 // 64
    <=
    assert // overflow
    intc_2 // 64
    bzero
    b|
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_boolean_route@7:
    // smart_contracts/avm_types/contract.algo.ts:28
    // public boolean(data: boolean): boolean {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    intc_1 // 0
    getbit
    // smart_contracts/avm_types/contract.algo.ts:28
    // public boolean(data: boolean): boolean {
    pushbytes 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_bytes_route@6:
    // smart_contracts/avm_types/contract.algo.ts:25
    // public bytes(data: bytes): bytes {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/avm_types/contract.algo.ts:25
    // public bytes(data: bytes): bytes {
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_stringArray_route@5:
    // smart_contracts/avm_types/contract.algo.ts:22
    // public stringArray(data: string[]): string[] {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_0 // 0x151f7c75
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/avm_types/contract.algo.ts:22
    // public stringArray(data: string[]): string[] {
    concat
    log
    intc_0 // 1
    return

main_string_route@4:
    // smart_contracts/avm_types/contract.algo.ts:19
    // public string(data: string): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/avm_types/contract.algo.ts:19
    // public string(data: string): string {
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_stringReadonly_route@3:
    // smart_contracts/avm_types/contract.algo.ts:15
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/avm_types/contract.algo.ts:15
    // @abimethod({ readonly: true })
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_bare_routing@40:
    // smart_contracts/avm_types/contract.algo.ts:14
    // export class AvmTypes extends Contract {
    txn OnCompletion
    bnz main_after_if_else@44
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return


// smart_contracts/avm_types/contract.algo.ts::AvmTypes.PaymentTxn(data: uint64) -> bytes:
PaymentTxn:
    // smart_contracts/avm_types/contract.algo.ts:40
    // public PaymentTxn(data: gtxn.PaymentTxn): bytes {
    proto 1 1
    // smart_contracts/avm_types/contract.algo.ts:41
    // return data.txnId
    frame_dig -1
    gtxns TxID
    retsub


// smart_contracts/avm_types/contract.algo.ts::AvmTypes.ApplicationCallTxn(data: uint64) -> bytes:
ApplicationCallTxn:
    // smart_contracts/avm_types/contract.algo.ts:43
    // public ApplicationCallTxn(data: gtxn.ApplicationCallTxn): bytes {
    proto 1 1
    // smart_contracts/avm_types/contract.algo.ts:44
    // return data.txnId
    frame_dig -1
    gtxns TxID
    retsub


// smart_contracts/avm_types/contract.algo.ts::AvmTypes.AssetTransferTxn(data: uint64) -> bytes:
AssetTransferTxn:
    // smart_contracts/avm_types/contract.algo.ts:46
    // public AssetTransferTxn(data: gtxn.AssetTransferTxn): bytes {
    proto 1 1
    // smart_contracts/avm_types/contract.algo.ts:47
    // return data.txnId
    frame_dig -1
    gtxns TxID
    retsub


// smart_contracts/avm_types/contract.algo.ts::AvmTypes.KeyRegistrationTxn(data: uint64) -> bytes:
KeyRegistrationTxn:
    // smart_contracts/avm_types/contract.algo.ts:49
    // public KeyRegistrationTxn(data: gtxn.KeyRegistrationTxn): bytes {
    proto 1 1
    // smart_contracts/avm_types/contract.algo.ts:50
    // return data.txnId
    frame_dig -1
    gtxns TxID
    retsub


// smart_contracts/avm_types/contract.algo.ts::AvmTypes.Transaction(data: uint64) -> bytes:
Transaction:
    // smart_contracts/avm_types/contract.algo.ts:52
    // public Transaction(data: gtxn.Transaction): bytes {
    proto 1 1
    // smart_contracts/avm_types/contract.algo.ts:53
    // return data.txnId
    frame_dig -1
    gtxns TxID
    retsub
